use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

use quote::quote;

use super::util;

const BUILTIN_FUNC_DEF_FILES: &'static [&str] = &[
    "builtin_funcs.def",
    "context_funcs.def",
    "ext_plugin_funcs.def",
    "general_funcs.def",
];

#[test]
fn codegen_funcs() {
    let typeck_module_dir = util::crate_dir().join("src/typeck");
    let typedef_dir = typeck_module_dir.join("typedefs");
    let generated_dir = typeck_module_dir.join("generated");

    let mut func_defs = Vec::new();
    for filename in BUILTIN_FUNC_DEF_FILES {
        func_defs.extend(collect_defs_in(&typedef_dir.join(filename)))
    }

    util::ensure_file_contents(generated_dir.join("funcs.rs"), generate(func_defs))
}

fn generate(defs: Vec<RawFuncDef>) -> String {
    let funcs = defs.iter().map(|def| {
        let name = &def.name;
        let doc = &def.doc;
        quote! {
            &Func { name: #name, doc: #doc }
        }
    });

    util::format(quote! {
        // Generated by codegen.rs; DO NOT EDIT.
        use crate::typeck::Func;

        pub const DEFINED_FUNCS: &'static [&Func] = &[
            #(#funcs),*
        ];
    })
}

#[derive(Debug)]
struct RawFuncDef {
    name: String,
    doc: String,
}

fn collect_defs_in(file: &Path) -> Vec<RawFuncDef> {
    let mut defs: Vec<RawFuncDef> = Vec::new();
    let reader = io::BufReader::new(File::open(file).unwrap());
    for (linenum, line) in reader.lines().enumerate() {
        let line = line.unwrap();
        if line.starts_with("//") {
            // comment; ignore
        } else if line.trim().is_empty() {
            // empty line; might be part of function documentation:
            if let Some(last_def) = defs.last_mut() {
                last_def.doc.push('\n');
            }
        } else if let Some(func_name) = line.strip_prefix("func ") {
            defs.push(RawFuncDef {
                name: func_name.to_string(),
                doc: String::new(),
            })
        } else if let Some(doc_line) = line.strip_prefix('\t') {
            let last_def = defs.last_mut().unwrap_or_else(|| {
                panic!(
                    "{}:{linenum}: could not identify function to attach indented documentation to",
                    file.display()
                )
            });
            last_def.doc.push_str(doc_line);
            last_def.doc.push('\n');
        } else {
            panic!("{}:{linenum}: could not interpret line as comment, function signature, or indented function documentation", file.display())
        }
    }

    for def in &mut defs {
        def.doc = util::unwrap_doc(def.doc.trim());
    }
    defs
}
