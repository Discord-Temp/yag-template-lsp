use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

use proc_macro2::TokenStream;
use quote::quote;

use super::util;

const BUILTIN_FUNC_DEF_FILES: &'static [&str] = &[
    "builtin_funcs.def",
    "context_funcs.def",
    "ext_plugin_funcs.def",
    "general_funcs.def",
];

#[test]
fn codegen_funcs() {
    let typeck_module_dir = util::crate_dir().join("src/typeck");
    let typedef_dir = typeck_module_dir.join("typedefs");

    let mut func_data = Vec::new();
    for filename in BUILTIN_FUNC_DEF_FILES {
        func_data.extend(collect_func_data(&typedef_dir.join(filename)))
    }

    let generated = generate(func_data);
    util::ensure_file_contents(typedef_dir.join("generated/funcs.rs"), generated)
}

fn generate(funcs: Vec<FuncData>) -> String {
    let mut generator = phf_codegen::Map::new();
    for func in funcs.iter() {
        let name = &func.name;
        let doc = &func.doc;
        let map_value_code = quote! {
            &Func { name: #name, doc: #doc }
        };

        generator.entry(&func.name, &map_value_code.to_string());
    }

    let phf_map_code: TokenStream = generator.build().to_string().parse().unwrap();
    util::format(quote! {
        // Generated by codegen.rs; DO NOT EDIT.
        use crate::typeck::Func;

        pub static FUNCS: phf::Map<&'static str, &'static Func> = #phf_map_code;
    })
}

#[derive(Debug)]
struct FuncData {
    name: String,
    doc: String,
}

fn collect_func_data(file: &Path) -> Vec<FuncData> {
    let mut defs: Vec<FuncData> = Vec::new();
    let reader = io::BufReader::new(File::open(file).unwrap());
    for (linenum, line) in reader.lines().enumerate() {
        let line = line.unwrap();
        if line.starts_with("//") {
            // comment; ignore
        } else if line.trim().is_empty() {
            // empty line; might be part of function documentation:
            if let Some(last_def) = defs.last_mut() {
                last_def.doc.push('\n');
            }
        } else if let Some(func_name) = line.strip_prefix("func ") {
            defs.push(FuncData {
                name: func_name.to_string(),
                doc: String::new(),
            })
        } else if let Some(doc_line) = line.strip_prefix('\t') {
            let last_def = defs.last_mut().unwrap_or_else(|| {
                panic!(
                    "{}:{linenum}: could not identify function to attach indented documentation to",
                    file.display()
                )
            });
            last_def.doc.push_str(doc_line);
            last_def.doc.push('\n');
        } else {
            panic!("{}:{linenum}: could not interpret line as comment, function signature, or indented function documentation", file.display())
        }
    }

    for def in &mut defs {
        def.doc = util::unwrap_doc(def.doc.trim());
    }
    defs
}
